'''
Created on Aug 2, 2016

Additional functionality for hypergraphs generated by converting a Petri net.
Post-processing: to remove tau-splits/joins nodes
Statistics of hypergraph

@author: UNIST
'''
import logging
import ast
from random import uniform
import logging
import sys

from halp.directed_hypergraph import DirectedHypergraph


"""
SMART CHOICE EXTENSIONS - START
"""

def smartchoice_attribute(hg: DirectedHypergraph, node, choice_attr, options):
    """
    Extends a node with an attribute-based smartchoice.
    The values of a "choice_attr" determine which edge will be chosen by ants
    :param node: the node in hg to be extended
    :param choice_attr: the attribute guiding the choice
    :param options: a dictionary of the type {attribute_value : output_edgge_id}
    :return:
    """
    logger = logging.getLogger(__name__)
    logger.debug("Extending for attribute-based smartchoice node: {0}".format(node))
    # check if node exists
    if hg.has_node(node):
        logger.debug("Node found: {0}".format(node))
        old_attrs = hg.get_node_attributes(node)
        # extend node with smartchoice attributes
        hg.add_node(node, old_attrs, choice_attr=choice_attr, opt_dict=options, smartchoice=True, smart_attribute=True)
        logger.debug("Node extended")
    else:
        logger.error("Node to extend with smartchoice not found: {0}".format(node))
    # extend node
    # return hg
    return hg

def smartchoice_node(hg: DirectedHypergraph, node, edge_probabilities):
    """
    Extends a node with a node-based smartchoice
    :param hg:
    :param node:
    :param probabilities: a dictionary of the probabilities with which ants will chose outgoing edges
    :return:
    """
    logger = logging.getLogger(__name__)
    logger.debug("Extending for node-based smartchoice node: {0}".format(node))
    if hg.has_node(node):
        logger.debug("Node found: {0}".format(node))
        old_attrs = hg.get_node_attributes(node)
        # extend node with smartchoice attributes
        hg.add_node(node, old_attrs, edge_prob=edge_probabilities, smartchoice=True, smart_node=True)
        logger.debug("Node extended")
    else:
        logger.error("Node to extend with smartchoice not found: {0}".format(node))
    return hg

def smartchoice_service(hg: DirectedHypergraph, node, service_uri, options):
    """
    extends a node with a service-based smartchoice
    :param hg:
    :param node:
    :param service_uri: the uri of the operation to invoke (REST service)
    :param options: a dictionary of the type {return value : chosen edge}
    :return:
    """
    logger = logging.getLogger(__name__)
    logger.debug("Extending for service-based smartchoice node: {0}".format(node))
    if hg.has_node(node):
        logger.debug("Node found: {0}".format(node))
        old_attrs = hg.get_node_attributes(node)
        # extend node with smartchoice attributes
        hg.add_node(node, old_attrs, uri=service_uri, opt_dict=options, smartchoice=True, smart_service=True)
        logger.debug("Node extended")
    else:
        logger.error("Node to extend with smartchoice not found: {0}".format(node))
    return hg

"""
SMART CHOICE EXTENSIONS - END
"""

def reset_pheromone(hg):
    '''
    Reset the pheromone level to a default (0.5)
    :param hg:
    '''
    hg_copy = DirectedHypergraph()
    for edge in hg.get_hyperedge_id_set():
        #hg_copy = hg.copy()
        PHERO_DEFAULT = 0.5
        head_edge = hg.get_hyperedge_head(edge)
        #head_edge = ast.literal_eval(head_edge)
        #print(head_edge)
        for head_node in head_edge:
            #print(head_node)
            attrs = hg.get_node_attributes(head_node)
            hg_copy.add_node(head_node,attrs)
        tail_edge = hg.get_hyperedge_tail(edge)
        #tail_edge = ast.literal_eval(tail_edge)
        for tail_node in tail_edge:
            attrs = hg.get_node_attributes(tail_node)
            hg_copy.add_node(tail_node,attrs)
        hg_copy.add_hyperedge(tail_edge, head_edge, phero = PHERO_DEFAULT, id = edge, name = edge)
    
    return hg_copy


def initialise_pheromone(hg, value):
    '''
    Reset the pheromone level to a default (0.5)
    :param hg:
    '''
    hg_copy = DirectedHypergraph()
    for edge in hg.get_hyperedge_id_set():
        # hg_copy = hg.copy()
        #PHERO_DEFAULT = 0.5
        head_edge = hg.get_hyperedge_head(edge)
        # head_edge = ast.literal_eval(head_edge)
        # print(head_edge)
        for head_node in head_edge:
            # print(head_node)
            attrs = hg.get_node_attributes(head_node)
            hg_copy.add_node(head_node, attrs)
        tail_edge = hg.get_hyperedge_tail(edge)
        # tail_edge = ast.literal_eval(tail_edge)
        for tail_node in tail_edge:
            attrs = hg.get_node_attributes(tail_node)
            hg_copy.add_node(tail_node, attrs)
        hg_copy.add_hyperedge(tail_edge, head_edge, phero=value, id=edge, name=edge)

    return hg_copy

def tau_post_processing(hg):
    """
    POST-PROCESSING of tau-split, tau-join nodes 
    reduces the hypergraph to remove explicit tau join and splits nodes, which are 
    substituted by hyperarcs
    :param hg
    """
    PHERO_DEFAULT = 100

    logger = logging.getLogger(__name__)
    logger.info("Post-processin of tau splits/joins started...")
    # tau-from-tree nodes don't have to be processed?
    # TO BE COMPLETED
    # TO BE COMPLETED
    nodes = hg.get_node_set()
    for node in nodes:
        node_name = hg.get_node_attribute(node, 'name')
        if node_name[:8] == 'tau join':
            #getbackward star
            b_star = hg.get_backward_star(node)
            #get tails of backward star h_edges
            tails = []
            for edge in b_star:
                tails = list(set(tails).union(hg.get_hyperedge_tail(edge)))
                hg.remove_hyperedge(edge)
            #create new h_edge
            head = []
            head.append(node)
            hg.add_hyperedge(tails, head, name = " ", phero = PHERO_DEFAULT)
        node_name = hg.get_node_attribute(node, 'name')
        if node_name[:9] == 'tau split':
            #get forward star
            f_star = hg.get_forward_star(node)
            heads = []
            for edge in f_star:
                heads = list(set(heads).union(hg.get_hyperedge_head(edge)))
                hg.remove_hyperedge(edge)
            #create new h_edge
            tail = []
            tail.append(node)
            hg.add_hyperedge(tail, heads, name = " ", phero = PHERO_DEFAULT)
    logger.info("...done")
    return hg


def tau_reduction(hg):
    """
    NOT CLEAR: DO NOT USE!!!!
    """
    logger = logging.getLogger(__name__)
    """ reduces a hypergraph by deleting the tau-split/join nodes"""
    nodes = hg.get_node_set()
    for node in nodes:
        node_name = hg.get_node_attribute(node, 'name')
        """ Reduce tau splits """
        if node_name[:9] == 'tau split' or node_name[:8] == 'tau join':
            logger.debug("Found new tau transition to reduce: {0}".format(node_name))
            #get forward star and build head for new hyperedge
            f_star = hg.get_forward_star(node)
            new_head = []
            for edge in f_star:
                new_head = list(set(new_head).union(hg.get_hyperedge_head(edge)))
            #remove current hyperedge
            hg.remove_hyperedge(edge)
            #get backward star and build tail of new hyperedge
            b_star = hg.get_backward_star(node)
            new_tail = []
            for edge in b_star:
                new_tail = list(set(new_tail).union(hg.get_hyperedge_tail(edge)))
            hg.remove_hyperedge(edge)
            #create new hyperedge
            hg.add_hyperedge(new_tail, new_head, name = " ", phero = 0.5)
    return hg


""" 
========================================================
some statistics of hypergraphs
========================================================
"""

def number_of_start_events(hg):
    nodes = hg.get_node_set()
    i = 0
    for node in nodes:
        is_source = hg.get_node_attribute(node, 'source')
        if is_source:
            i = i+1
    return i
    
    
def number_of_end_events(hg):
    nodes = hg.get_node_set()
    i = 0
    for node in nodes:
        is_source = hg.get_node_attribute(node, 'sink')
        if is_source:
            i = i+1
    return i

def number_of_xor_splits(hg):
    """ returns number of xor-splits"""
    return get_statistics(hg)['xor-split']

def number_of_xor_joints(hg):
    """ returns number of xor-joints"""
    return get_statistics(hg)['xor-join']

def number_of_activities(hg):
    """ returns number of activities (ie. number of transitions excluding xor splits and joins)"""
    return get_statistics(hg)['activities']

def number_of_transitions(hg):
    """returns total number of transitions (including xor splits/joins)"""
    return get_statistics(hg)['transitions']

def get_statistics(hg):
    """ returns some basic statistics of the hypergraph in a dictionary"""
    stats = {}
    xor_splits = 0
    xor_joins = 0
    total_trans = 0
    activities = 0
    nodes = hg.get_node_set()
    for node in nodes:
        total_trans = total_trans + 1
        #print(hg.get_node_attributes(node))
        node_type = hg.get_node_attribute(node,'type')
        if node_type == "xor-split":
            xor_splits = xor_splits + 1
        elif node_type == "xor-join":
            xor_joins = xor_joins + 1
        else:
            activities = activities + 1
            
    stats.update({'xor-split' : xor_splits})
    stats.update({'xor-join' : xor_joins})
    stats.update({'activities' : activities})
    stats.update({'transitions' : total_trans})
    return stats

def print_statistics(hg):
    """
    Displays statistics on standard output
    """
    print(str(get_statistics(hg)))





if __name__ == "__main__":
    pass
